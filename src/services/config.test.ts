import { afterEach, beforeEach, describe, expect, test } from 'bun:test';
import { mkdir, rm } from 'node:fs/promises';
import { join } from 'node:path';
import { type HermesConfig, readConfig, writeConfig } from './config';

describe('config service', () => {
  const testConfigDir = '.hermes-test';
  const originalCwd = process.cwd();
  let testDir: string;

  beforeEach(async () => {
    // Create a temporary test directory
    testDir = join(originalCwd, testConfigDir);
    await mkdir(testDir, { recursive: true });
    process.chdir(testDir);
  });

  afterEach(async () => {
    process.chdir(originalCwd);
    // Clean up test directory
    try {
      await rm(testDir, { recursive: true, force: true });
    } catch {
      // Ignore cleanup errors
    }
  });

  describe('readConfig', () => {
    test('returns undefined when config file does not exist', async () => {
      const config = await readConfig();
      expect(config).toBeUndefined();
    });

    test('reads valid config with all fields', async () => {
      await mkdir('.hermes', { recursive: true });
      await Bun.write(
        '.hermes/config.yml',
        `
tigerServiceId: svc-123
agent: claude
model: sonnet
`,
      );

      const config = await readConfig();
      expect(config).toEqual({
        tigerServiceId: 'svc-123',
        agent: 'claude',
        model: 'sonnet',
      });
    });

    test('reads config with only agent field', async () => {
      await mkdir('.hermes', { recursive: true });
      await Bun.write(
        '.hermes/config.yml',
        `
agent: opencode
`,
      );

      const config = await readConfig();
      expect(config).toEqual({
        agent: 'opencode',
      });
    });

    test('reads config with null tigerServiceId', async () => {
      await mkdir('.hermes', { recursive: true });
      await Bun.write(
        '.hermes/config.yml',
        `
tigerServiceId: null
agent: claude
`,
      );

      const config = await readConfig();
      expect(config).toEqual({
        tigerServiceId: null,
        agent: 'claude',
      });
    });

    test('returns empty object for empty config file', async () => {
      await mkdir('.hermes', { recursive: true });
      await Bun.write('.hermes/config.yml', '');

      const config = await readConfig();
      expect(config).toEqual({});
    });

    test('returns empty object for config with only comments', async () => {
      await mkdir('.hermes', { recursive: true });
      await Bun.write(
        '.hermes/config.yml',
        `
# This is a comment
# Another comment
`,
      );

      const config = await readConfig();
      expect(config).toEqual({});
    });
  });

  describe('writeConfig', () => {
    test('writes config with all fields', async () => {
      const config: HermesConfig = {
        tigerServiceId: 'svc-456',
        agent: 'opencode',
        model: 'gpt-4',
      };

      await writeConfig(config);

      const content = await Bun.file('.hermes/config.yml').text();
      expect(content).toContain('tigerServiceId: svc-456');
      expect(content).toContain('agent: opencode');
      expect(content).toContain('model: gpt-4');
    });

    test('writes config and creates .hermes directory', async () => {
      const config: HermesConfig = {
        agent: 'claude',
      };

      await writeConfig(config);

      const fileExists = await Bun.file('.hermes/config.yml').exists();
      expect(fileExists).toBe(true);
    });

    test('writes config with null tigerServiceId', async () => {
      const config: HermesConfig = {
        tigerServiceId: null,
        agent: 'claude',
      };

      await writeConfig(config);

      const content = await Bun.file('.hermes/config.yml').text();
      expect(content).toContain('tigerServiceId: null');
    });

    test('overwrites existing config', async () => {
      await mkdir('.hermes', { recursive: true });
      await Bun.write('.hermes/config.yml', 'agent: opencode\n');

      await writeConfig({ agent: 'claude', model: 'sonnet' });

      const config = await readConfig();
      expect(config?.agent).toBe('claude');
      expect(config?.model).toBe('sonnet');
    });

    test('includes header comments', async () => {
      await writeConfig({ agent: 'claude' });

      const content = await Bun.file('.hermes/config.yml').text();
      expect(content).toContain('# Hermes configuration');
      expect(content).toContain('# Generated by');
    });
  });

  describe('roundtrip', () => {
    test('config can be written and read back', async () => {
      const original: HermesConfig = {
        tigerServiceId: 'svc-roundtrip',
        agent: 'claude',
        model: 'opus',
      };

      await writeConfig(original);
      const readBack = await readConfig();

      expect(readBack).toEqual(original);
    });

    test('config with undefined fields can be written and read back', async () => {
      const original: HermesConfig = {
        agent: 'opencode',
      };

      await writeConfig(original);
      const readBack = await readConfig();

      expect(readBack?.agent).toBe('opencode');
      expect(readBack?.tigerServiceId).toBeUndefined();
      expect(readBack?.model).toBeUndefined();
    });
  });
});
