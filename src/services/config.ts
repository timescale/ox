// ============================================================================
// Configuration Service - Read/write .hermes/config.yml file
// ============================================================================

import { mkdir } from 'node:fs/promises';
import { homedir } from 'node:os';
import { join } from 'node:path';
import { YAML } from 'bun';

const CONFIG_DIR = '.hermes';
const CONFIG_FILENAME = 'config.yml';
const LOCAL_CONFIG_PATH = join(CONFIG_DIR, CONFIG_FILENAME);
const HOME_CONFIG_PATH = join(homedir(), CONFIG_DIR, CONFIG_FILENAME);

export type AgentType = 'claude' | 'opencode';

export interface HermesConfig {
  // Tiger service ID to use as the default parent for database forks
  // null = explicitly "none" (skip DB fork by default)
  // undefined = not set (use tiger CLI default)
  tigerServiceId?: string | null;

  // Default agent to use (claude or opencode)
  agent?: AgentType;

  // Default model to use for the selected agent
  model?: string;
}

/**
 * Read a config file from the given path
 * Returns undefined if the file doesn't exist
 */
async function readConfigFile(path: string): Promise<HermesConfig | undefined> {
  const file = Bun.file(path);
  if (!(await file.exists())) {
    return undefined;
  }

  const content = await file.text();
  const parsed = YAML.parse(content);

  // Handle empty file or invalid YAML
  if (!parsed || typeof parsed !== 'object') {
    return {};
  }

  return parsed as HermesConfig;
}

/**
 * Merge two config objects, with the first taking precedence.
 * A value from `primary` is used if it's not undefined; otherwise `fallback` is used.
 * This preserves explicit `null` values from primary.
 */
export function mergeConfig(
  primary: HermesConfig | undefined,
  fallback: HermesConfig | undefined,
): HermesConfig {
  if (!primary && !fallback) {
    return {};
  }
  if (!fallback) {
    return { ...primary };
  }
  if (!primary) {
    return { ...fallback };
  }

  const result = {} as Record<string, unknown>;

  // Get all keys from both configs
  const allKeys = new Set([...Object.keys(primary), ...Object.keys(fallback)]);

  for (const key of allKeys) {
    const primaryVal = (primary as Record<string, unknown>)[key];
    const fallbackVal = (fallback as Record<string, unknown>)[key];
    // Use primary value if defined (including null), otherwise fallback
    result[key] = primaryVal !== undefined ? primaryVal : fallbackVal;
  }

  return result as HermesConfig;
}

/**
 * Read the local .hermes/config.yml file from the current directory
 * Returns undefined if the file doesn't exist
 */
export async function readLocalConfig(): Promise<HermesConfig | undefined> {
  return readConfigFile(LOCAL_CONFIG_PATH);
}

/**
 * Read the global ~/.hermes/config.yml file from the home directory
 * Returns undefined if the file doesn't exist
 */
export async function readHomeConfig(): Promise<HermesConfig | undefined> {
  return readConfigFile(HOME_CONFIG_PATH);
}

/**
 * Read merged config: local values take precedence over home values
 * Returns undefined if neither config file exists
 */
export async function readConfig(): Promise<HermesConfig | undefined> {
  const [localConfig, homeConfig] = await Promise.all([
    readLocalConfig(),
    readHomeConfig(),
  ]);

  if (!localConfig && !homeConfig) {
    return undefined;
  }

  return mergeConfig(localConfig, homeConfig);
}

/**
 * Write the .hermes/config.yml file to the current directory
 * Creates the .hermes directory if it doesn't exist
 */
export async function writeConfig(config: HermesConfig): Promise<void> {
  // Ensure .hermes directory exists
  await mkdir(CONFIG_DIR, { recursive: true });
  await Bun.write(
    LOCAL_CONFIG_PATH,
    `# Hermes configuration
# Generated by 'hermes init'
# https://github.com/timescale/hermes
---
${YAML.stringify(config, null, 2)}
`,
  );
}
