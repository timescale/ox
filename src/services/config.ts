// ============================================================================
// Configuration Service - Read/write YAML config files
// ============================================================================

import { mkdir } from 'node:fs/promises';
import { join } from 'node:path';
import { YAML } from 'bun';
import envPaths from 'env-paths';

// ============================================================================
// Types
// ============================================================================

export type AgentType = 'claude' | 'opencode';

/** Project-specific config stored in .hermes/config.yml */
export interface ProjectConfig {
  // Tiger service ID to use as the default parent for database forks
  // null = explicitly "none" (skip DB fork by default)
  // undefined = not set
  tigerServiceId?: string | null;

  // Default agent to use (claude or opencode)
  agent?: AgentType;

  // Default model to use for the selected agent
  model?: string;
}

/** User-level preferences stored in OS-specific config directory */
export interface UserConfig {
  // UI theme
  themeName?: string;
}

/** @deprecated Use ProjectConfig or UserConfig instead */
export type HermesConfig = ProjectConfig & UserConfig;

// ============================================================================
// Config Store Factory
// ============================================================================

interface ConfigStoreOptions {
  /** Function that returns the config directory path */
  getConfigDir: () => string;
  /** Header comment for the YAML file */
  headerComment: string;
}

interface ConfigStore<T extends object> {
  /** Get the config directory path */
  getConfigDir: () => string;
  /** Read the entire config file */
  read: () => Promise<T | undefined>;
  /** Read a single config value */
  readValue: <K extends keyof T>(key: K) => Promise<T[K] | undefined>;
  /** Write the entire config file */
  write: (config: T) => Promise<void>;
  /** Write a single config value */
  writeValue: <K extends keyof T>(key: K, value: T[K]) => Promise<void>;
}

const CONFIG_FILENAME = 'config.yml';

function createConfigStore<T extends object>(
  options: ConfigStoreOptions,
): ConfigStore<T> {
  const { getConfigDir, headerComment } = options;
  const configPath = () => join(getConfigDir(), CONFIG_FILENAME);

  const read = async (): Promise<T | undefined> => {
    const file = Bun.file(configPath());
    if (!(await file.exists())) {
      return undefined;
    }

    const content = await file.text();
    const parsed = YAML.parse(content);

    // Handle empty file or invalid YAML
    if (!parsed || typeof parsed !== 'object') {
      return {} as T;
    }

    return parsed as T;
  };

  const readValue = async <K extends keyof T>(
    key: K,
  ): Promise<T[K] | undefined> => {
    const config = await read();
    return config?.[key];
  };

  const write = async (config: T): Promise<void> => {
    await mkdir(getConfigDir(), { recursive: true });
    await Bun.write(
      configPath(),
      `${headerComment}---\n${YAML.stringify(config, null, 2)}`,
    );
  };

  const writeValue = async <K extends keyof T>(
    key: K,
    value: T[K],
  ): Promise<void> => {
    const config = (await read()) || ({} as T);
    config[key] = value;
    await write(config);
  };

  return {
    getConfigDir,
    read,
    readValue,
    write,
    writeValue,
  };
}

// ============================================================================
// Config Store Instances
// ============================================================================

/** Project config directory: .hermes/ in the current working directory */
export const hermesConfigDir = () => join(process.cwd(), '.hermes');

/** User config directory: OS-specific config path (e.g., ~/.config/hermes on Linux) */
const userConfigDir = () => envPaths('hermes', { suffix: '' }).config;

/** Project-specific configuration stored in .hermes/config.yml */
export const projectConfig = createConfigStore<ProjectConfig>({
  getConfigDir: hermesConfigDir,
  headerComment: `# Hermes project configuration
# Generated by 'hermes config'
# https://github.com/timescale/hermes
`,
});

/** User-level preferences stored in OS-specific config directory */
export const userConfig = createConfigStore<UserConfig>({
  getConfigDir: userConfigDir,
  headerComment: `# Hermes user preferences
# https://github.com/timescale/hermes
`,
});

// ============================================================================
// Legacy API (Deprecated)
// ============================================================================

/**
 * Read the .hermes/config.yml file from the current directory
 * Returns undefined if the file doesn't exist
 * @deprecated Use projectConfig.read() instead
 */
export async function readConfig(): Promise<HermesConfig | undefined> {
  return projectConfig.read();
}

/**
 * @deprecated Use projectConfig.readValue() instead
 */
export const readConfigValue = async <K extends keyof ProjectConfig>(
  key: K,
): Promise<ProjectConfig[K] | undefined> => {
  return projectConfig.readValue(key);
};

/**
 * Write the .hermes/config.yml file to the current directory
 * Creates the .hermes directory if it doesn't exist
 * @deprecated Use projectConfig.write() instead
 */
export async function writeConfig(config: HermesConfig): Promise<void> {
  return projectConfig.write(config);
}

/**
 * @deprecated Use projectConfig.writeValue() instead
 */
export const writeConfigValue = async <K extends keyof ProjectConfig>(
  key: K,
  value: ProjectConfig[K],
): Promise<void> => {
  return projectConfig.writeValue(key, value);
};
